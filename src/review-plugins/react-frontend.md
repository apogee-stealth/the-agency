---
name: React & Frontend Checks
applies_when: Changed files include .tsx, .jsx, .css, .scss, or .styled.ts files
---

- [ ] **Hard-coded colors**: Are there hex values, `rgb()`, or named colors that should use theme variables or design tokens?
- [ ] **Missing data-cy attributes**: Do new interactive elements (buttons, inputs, links, dropdowns) have `data-cy` attributes for end-to-end testing?
- [ ] **Accessibility gaps**: Missing `alt` text on images? Click handlers on non-interactive elements (`div`, `span`) without proper roles? Missing `aria-label` on icon-only buttons?
- [ ] **One public component per file**: Each `.tsx` file should export only one React component. If additional helper components exist in the same file, they must NOT be exported and should have a `/** @private */` JSDoc comment above their declaration. Flag any file that exports multiple components, or has unexported components missing the `@private` pragma.
- [ ] **No direct component tests**: `.tsx` component files should NOT have corresponding `.test.tsx` or `.spec.tsx` test files. Style-only hooks (e.g., `useStyles`, `useTheme`) also do not need tests UNLESS the hook contains conditional logic that affects code paths beyond styling. Flag any new test file that directly tests a `.tsx` component or a pure-styling hook.
- [ ] **BEM class naming**: CSS class names must follow BEM (Block Element Modifier) convention: `.block__element--modifier`. Flag class names that use camelCase, generic names without BEM structure, or inconsistent delimiter usage (e.g., single underscores or hyphens where BEM expects doubles).
- [ ] **Rem units over pixels**: Use `rem` for all sizing and spacing values. `px` is acceptable ONLY for media query breakpoints. Flag any `px` usage in properties like `font-size`, `margin`, `padding`, `width`, `height`, `gap`, `border-radius`, etc.
- [ ] **Inline styles**: Flag `style={{...}}` props in JSX. Styling should live in stylesheets, styled components, or style hooks — not inline objects. Exceptions: truly dynamic values computed at runtime (e.g., positioning from a calculation) are acceptable, but static visual properties (`color`, `padding`, `fontSize`) are not.
- [ ] **Missing `key` on dynamic lists**: Flag `.map()` calls that return JSX without a `key` prop. Also flag usage of array index as `key` on lists that can be reordered, filtered, or have items added/removed — index keys cause subtle re-render bugs in those cases. Stable identifiers (IDs, slugs) are required.
- [ ] **Direct DOM manipulation**: Flag usage of `document.querySelector`, `document.getElementById`, `document.createElement`, `.innerHTML`, `.innerText` assignment, or `.appendChild`. React components should use refs (`useRef`) for DOM access and state for DOM updates. Direct DOM manipulation bypasses React's reconciliation and causes stale UI.
- [ ] **Inline event handler allocation in lists**: Flag arrow functions defined directly in JSX event props (`onClick={() => handler(id)}`) when they appear inside `.map()` or other list-rendering patterns. These create a new function reference per render per item. Extract to a named handler or use `useCallback`. Single-instance components (not in a loop) are fine.
- [ ] **Derived state anti-pattern**: Flag `useState` + `useEffect` pairs where the effect's only job is to compute a value from other state or props and store it back into state. This should be `useMemo` (for expensive computations) or a plain `const` (for cheap ones). The pattern creates unnecessary render cycles and is a common source of stale-state bugs.
- [ ] **Hardcoded user-facing strings**: Flag literal text strings rendered in JSX that a user would see on screen — headings, button labels, tooltips, placeholder text, error messages, `aria-label` values. These should use the project's i18n system (e.g., `t('key')`). Do NOT flag non-user-facing strings like prop names, CSS classes, `data-cy` values, log messages, or enum/constant comparisons.
- [ ] **Missing error boundaries**: Flag new top-level route components or major feature entry-point components that are not wrapped in an error boundary. An unhandled throw in a component tree without a boundary will unmount the entire app. Leaf components and small utility components do not need their own boundaries.
- [ ] **Prop drilling**: Flag props being passed through two or more intermediate components that don't use them — they just forward them deeper. This suggests the value should live in a React context, a state management store, or the component tree should be restructured using composition (children/render props). Name the prop and the pass-through chain in your finding.
- [ ] **Non-memoized context values**: Flag React context providers where the `value` prop is an object literal, array literal, or function created inline (e.g., `<Ctx.Provider value={{ user, setUser }}>`). Every render creates a new reference, forcing all consumers to re-render. Wrap the value in `useMemo` (objects/arrays) or `useCallback` (functions).
- [ ] **`useEffect` missing cleanup**: Flag `useEffect` hooks that create subscriptions (e.g., `addEventListener`, WebSocket connections, `subscribe()` calls), timers (`setTimeout`, `setInterval`), or `AbortController` instances without returning a cleanup function that tears them down. Also flag `async` operations in effects that set state after completion without checking whether the component is still mounted (missing abort signal or cancelled flag). These are memory leak and state-update-after-unmount bugs.
