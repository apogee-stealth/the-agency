---
name: Node Backend Checks
applies_when: Changed files include .ts files in backend or service directories (excluding test files)
---

- [ ] **Console.log usage**: Is `console.log` used instead of the project's structured logger?
- [ ] **Boundary violations**: Is a handler reaching into a repository directly instead of going through a service layer?
- [ ] **Raw SQL**: Are there string-concatenated queries instead of parameterized queries via the project's query builder?
- [ ] **Error swallowing**: Are errors being caught and silently discarded without logging or re-throwing?
- [ ] **Readability at a glance**: Can a developer unfamiliar with this code follow the logic 6 months from now? Flag functions longer than ~40 lines that lack decomposition, deeply nested conditionals (3+ levels), boolean parameters without named constants or descriptive variable assignments, and variable names that are ambiguous or require context to interpret (e.g., `data`, `result`, `temp`, `val`, single-letter names outside of trivial loops).
- [ ] **Documentation gaps**: Public functions and methods should have JSDoc comments documenting purpose, parameters, and return values. Non-obvious logic — workarounds, business rules, performance trade-offs, "this looks wrong but isn't" patterns — should have inline comments explaining _why_, not _what_. Flag new public functions missing JSDoc and non-trivial logic blocks that would confuse a reader without context.
- [ ] **N+1 query patterns**: Flag loops that execute a database call (find, findOne, aggregate, query, get, fetch) per iteration instead of batching. This includes `for` loops, `.forEach`, `.map`, and `for...of` over a collection where each iteration hits the DB. The fix is typically a single bulk query (`$in`, `WHERE IN`, `mget`, pipeline) before the loop, then an in-memory lookup. Also flag `Promise.all` wrapping per-item DB calls — it's parallel but still N round-trips.
- [ ] **Unvalidated external input**: Flag request body fields, query parameters, route parameters, and header values used directly in business logic or DB queries without schema validation (e.g., zod, joi, class-validator). Trusting `req.body.email` without parsing it is an injection and type-safety risk. Internal function-to-function calls within the service layer do NOT need validation — only system boundaries (HTTP handlers, queue consumers, webhook receivers).
- [ ] **Leaking internals in API responses**: Flag error handlers or response payloads that expose stack traces, raw database error messages, internal collection/table names, internal IDs (like MongoDB `_id` when a public-facing ID exists), or implementation details (library names, file paths). API consumers should get structured error codes and user-safe messages, not a guided tour of your infrastructure.
- [ ] **Race conditions in async code**: Flag missing `await` on promises whose result or side effects matter (fire-and-forget is only acceptable for truly independent, failure-tolerant operations like analytics). Flag parallel mutations to shared state (e.g., two `await` calls that both read-then-write the same document without guarding against interleaving). Flag `Promise.all` over operations that have implicit ordering dependencies.
- [ ] **Overly broad try/catch**: Flag `try` blocks spanning more than ~15-20 lines or wrapping multiple distinct operations where the `catch` handles all failures identically. Different failure modes (network error, validation error, auth error, DB constraint violation) usually need different responses. If a single `catch(e)` logs and returns a generic 500 for all of them, flag it. Each distinct failure mode should be catchable and handleable separately.
- [ ] **Hardcoded magic numbers**: Flag raw numeric literals used for timeouts, retry counts, page sizes, rate limits, cache TTLs, port numbers, or threshold values. These should be named constants or pulled from configuration. `setTimeout(fn, 30000)` is unreadable; `setTimeout(fn, CACHE_TTL_MS)` communicates intent. Exceptions: `0`, `1`, `-1` in obvious arithmetic/index contexts, and HTTP status codes (e.g., `res.status(404)`) are fine.
